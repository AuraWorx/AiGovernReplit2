import { pgTable, text, serial, integer, boolean, timestamp, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";

// ---------- Users and Auth ----------
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(), // Password hash
  email: text("email").notNull().unique(),
  fullName: text("full_name").notNull(),
  role: text("role").notNull().default("user"), // e.g., 'user', 'admin', 'manager'
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
});

export const usersRelations = relations(users, ({ one }) => ({
  tenant: one(tenants, { fields: [users.tenantId], references: [tenants.id] }),
}));

export const insertUserSchema = createInsertSchema(users, {
  username: (schema) => schema.min(3, "Username must be at least 3 characters"),
  // Password validation happens before hashing, not via Zod on the hash itself
  email: (schema) => schema.email("Must provide a valid email"),
  fullName: (schema) => schema.min(1, "Full name is required"),
  // Exclude fields generated by DB or set server-side
}).omit({ id: true, createdAt: true, updatedAt: true });

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

// ---------- Tenants ----------
export const tenants = pgTable("tenants", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  schemaName: text("schema_name").notNull().unique(), // Potentially for future schema isolation
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
});

export const tenantsRelations = relations(tenants, ({ many }) => ({
  users: many(users),
  datasets: many(datasets),
  webhooks: many(webhooks),
  analyses: many(analyses), // Added relation
  activities: many(activities), // Added relation
}));

export type Tenant = typeof tenants.$inferSelect;

// ---------- Datasets ----------
export const datasets = pgTable("datasets", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  fileName: text("file_name").notNull(), // Original filename from upload
  fileSize: integer("file_size").notNull(), // Size in bytes
  fileType: text("file_type").notNull(), // Mime type
  // REMOVED: filePath: text("file_path").notNull(),
  s3Bucket: text("s3_bucket"), // ADDED: S3 Bucket name where the file is stored
  s3Key: text("s3_key"),       // ADDED: S3 Object key for the file
  uploadedById: integer("uploaded_by_id").references(() => users.id).notNull(),
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
});

export const datasetsRelations = relations(datasets, ({ one, many }) => ({
  tenant: one(tenants, { fields: [datasets.tenantId], references: [tenants.id] }),
  uploadedBy: one(users, { fields: [datasets.uploadedById], references: [users.id] }),
  analyses: many(analyses), // Analyses performed on this dataset
}));

// Zod schema for inserting datasets (server-side populates s3 info)
export const insertDatasetSchema = createInsertSchema(datasets, {
  name: (schema) => schema.min(1, "Name is required"),
  fileName: (schema) => schema.min(1, "Filename is required"),
  fileType: (schema) => schema.min(1, "File type is required"),
  fileSize: (schema) => schema.int().positive("File size must be positive"),
}).omit({ id: true, createdAt: true, updatedAt: true, s3Bucket: true, s3Key: true }); // Omit auto-generated/server-set fields

export type InsertDataset = z.infer<typeof insertDatasetSchema>;
export type Dataset = typeof datasets.$inferSelect;

// ---------- Webhooks ----------
export const webhooks = pgTable("webhooks", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  endpoint: text("endpoint").notNull(), // URL to send data TO
  secret: text("secret"), // Optional secret for verifying incoming requests
  isActive: boolean("is_active").notNull().default(true),
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  createdById: integer("created_by_id").references(() => users.id).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
});

export const webhooksRelations = relations(webhooks, ({ one, many }) => ({
  tenant: one(tenants, { fields: [webhooks.tenantId], references: [tenants.id] }),
  createdBy: one(users, { fields: [webhooks.createdById], references: [users.id] }),
  dataIncoming: many(webhookData), // Data received FROM this webhook endpoint
}));

export type Webhook = typeof webhooks.$inferSelect;

// ---------- Webhook Data ----------
// Stores data received FROM configured webhook endpoints
export const webhookData = pgTable("webhook_data", {
  id: serial("id").primaryKey(),
  // This refers to the webhook CONFIGURATION that received the data, not the source sending it.
  // Renaming might be clearer, e.g., `receivingWebhookConfigId`
  webhookId: integer("webhook_id").references(() => webhooks.id).notNull(),
  payload: jsonb("payload").notNull(), // The actual data received
  processedAt: timestamp("processed_at", { withTimezone: true }), // Timestamp when analysis started/completed
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
});

export const webhookDataRelations = relations(webhookData, ({ one, many }) => ({
  webhook: one(webhooks, { fields: [webhookData.webhookId], references: [webhooks.id] }),
  analyses: many(analyses), // Analyses performed on this received data
}));

export type WebhookData = typeof webhookData.$inferSelect;

// ---------- Analyses ----------
export const analyses = pgTable("analyses", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  analysisType: text("analysis_type").notNull(), // e.g., 'bias_analysis', 'pii_detection'
  status: text("status").notNull().default("pending"), // 'pending', 'queued', 'processing', 'completed', 'failed'
  datasetId: integer("dataset_id").references(() => datasets.id), // Link to dataset if source was upload
  webhookDataId: integer("webhook_data_id").references(() => webhookData.id), // Link to webhook data if source was webhook
  resultsPath: text("results_path"), // Path to results (e.g., S3 URI or error message on failure)
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  initiatedById: integer("initiated_by_id").references(() => users.id).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  completedAt: timestamp("completed_at", { withTimezone: true }), // Timestamp when processing finished (success or fail)
});

export const analysesRelations = relations(analyses, ({ one }) => ({
  tenant: one(tenants, { fields: [analyses.tenantId], references: [tenants.id] }),
  initiatedBy: one(users, { fields: [analyses.initiatedById], references: [users.id] }),
  dataset: one(datasets, { fields: [analyses.datasetId], references: [datasets.id] }),
  webhookData: one(webhookData, { fields: [analyses.webhookDataId], references: [webhookData.id] }),
}));

export type Analysis = typeof analyses.$inferSelect;

// ---------- Activities (Audit Log) ----------
export const activities = pgTable("activities", {
  id: serial("id").primaryKey(),
  action: text("action").notNull(), // e.g., 'user_login', 'dataset_uploaded', 'analysis_completed'
  description: text("description").notNull(), // Human-readable description
  entityType: text("entity_type"), // Optional: Type of entity involved (e.g., 'dataset', 'webhook')
  entityId: integer("entity_id"),   // Optional: ID of the entity involved
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(), // User performing the action
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
});

export const activitiesRelations = relations(activities, ({ one }) => ({
  tenant: one(tenants, { fields: [activities.tenantId], references: [tenants.id] }),
  user: one(users, { fields: [activities.userId], references: [users.id] }),
}));

export type Activity = typeof activities.$inferSelect;
